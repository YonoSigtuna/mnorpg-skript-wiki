<html>
	<head>
		<meta charset="utf-8">
		<title>MNORPG's Skript Wiki💧</title>
		<link rel="stylesheet" href="static/css/style.css">
		<script>
			function hidecomment(thiselement){
				var classElements = document.getElementsByClassName('comment');
				for (var i=0; i<classElements.length; i++) {
					classElements[i].style.display = 'none';
				}
				thiselement.style.display='none';
				thiselement.nextElementSibling.style.display='block';
			}
			function showcomment(thiselement){
				var classElements = document.getElementsByClassName('comment');
				for (var i=0; i<classElements.length; i++) {
					classElements[i].style.display = 'inline';
				}
				thiselement.previousElementSibling.style.display='block';
				thiselement.style.display='none';				
			}
			function content_level_1(thiselement){
				var i;
				var navall = document.getElementsByTagName('nav')[0].childNodes[1].getElementsByTagName('li');
				for (i=0; i<navall.length; i++) navall[i].style.display = 'none';
				var navsec = document.getElementsByTagName('nav')[0].childNodes[1].childNodes;
				for (i=1; i<navsec.length; i+=2) navsec[i].style.display = 'block';
				thiselement.style.display='none';
				thiselement.nextElementSibling.style.display='block';
			}
			function content_level_2(thiselement){
				var i,j;
				var navall = document.getElementsByTagName('nav')[0].childNodes[1].getElementsByTagName('li');
				for (i=0; i<navall.length; i++) {
					navall[i].style.display = 'none';
				}
				var navsec = document.getElementsByTagName('nav')[0].childNodes[1].childNodes;
				var navsubsec;

				navsec[1].style.display = 'block';
				navsec[3].style.display = 'block';
				navsubsec = navsec[3].childNodes[2].childNodes;
				for (j=1; j<navsubsec.length; j+=2) navsubsec[j].style.display = 'block';

				for (i=5; i<navsec.length; i+=2) {
					navsec[i].style.display = 'block';
					if(navsec[i].childNodes.length>=2){
						navsubsec = navsec[i].childNodes[1].childNodes;
						for (j=1; j<navsubsec.length; j+=2) navsubsec[j].style.display = 'block';
					}
				}
				thiselement.style.display='none';
				thiselement.nextElementSibling.style.display='block';
			}
			function content_level_3(thiselement){
				var i;
				var navall = document.getElementsByTagName('nav')[0].childNodes[1].getElementsByTagName('li');
				for (i=0; i<navall.length; i++) navall[i].style.display = 'block';
				thiselement.style.display='none';
				thiselement.previousElementSibling.previousElementSibling.style.display='block';
			}
			function loadpage(){
				var files=document.getElementsByClassName("file");
				for (var i=0;i<files.length;i++) {
					files[i].onclick=function (){
						var j=1;
						if (this.nextElementSibling.style.display=='none') j=0;
						if (j==1) this.nextElementSibling.style.display='none';
						else this.nextElementSibling.style.display='block';
					}
				}
			}
		</script>
	</head>

<body>
	<!-- 目录列表 -->
	<nav>
		<ul>
			<!-- 1 -->
			<li><a href="#1"" style="font-weight: bold; text-align: center;">1. What is MNORPG?</a><ul>
			<li><a  href="#1.1">1.1 MNORPG在RPG游戏中的定位</a></li>
			<li><a  href="#1.2">1.2 MNORPG第一主题 - 具现化</a></li>
			<li><a  href="#1.3">1.3 MNORPG第二主题 - 成长</a></li></ul></li>
			<!-- 2 -->
			<li><a href="#2"" style="font-weight: bold; text-align: center;">2. 服务器版本的选择</a><ul>
			<li><a  href="#2.1">2.1 游戏版本的选择</a></li>
			<li><a  href="#2.2">2.2 服务端核心的选择</a></li></ul></li>
			<!-- 3 -->
			<li><a href="#3"" style="font-weight: bold; text-align: center;">3. Skript的介绍</a><ul>
			<li><a  href="#3.1">3.1 Skript的基本结构</a></li>
			<li><a  href="#3.2">3.2 Skript及扩展的下载</a></li></ul></li>
			<!-- 4 -->
			<li><a href="#4"" style="font-weight: bold; text-align: center;">4. 学习Skript需要的准备</a><ul>
			<li><a  href="#4">4.1 Skript的定位</a></li>
			<li><a  href="#4.2">4.2 编写工具</a></li>
			<li><a  href="#4.3">4.3 善用DOC</a></li>
			<li><a  href="#4.4">4.4 笔记的重要性</a></li></ul></li>
			<!-- 5 -->
			<li><a href="#5"" style="font-weight: bold; text-align: center;">5. Skript的例子分析</a><ul>
			<li><a  href="#5.1">5.1 脚本命名规则</a></li>
			<li><a  href="#5.2">5.2 command with cooldown.sk</a></li>
			<li><a  href="#5.2">5.3 custom helmet.sk</a></li>
			<li><a  href="#5.2">5.4 disable weather.sk</a></li>
			<li><a  href="#5.2">5.5 eternal day.sk</a></li>
			<li><a  href="#5.2">5.6 furnace automatisation.sk</a></li>
			<li><a  href="#5.2">5.7 homes.sk</a></li>
			<li><a  href="#5.2">5.8 item command.sk</a></li>
			<li><a  href="#5.2">5.9 kill counter.sk</a></li>
			<li><a  href="#5.2">5.10 nerf endermen.sk</a></li>
			<li><a  href="#5.2">5.11 realistic drops.sk</a></li>
			<li><a  href="#5.2">5.12 simple god mode.sk</a></li>
			<li><a  href="#5.2">5.13 simple join and leave message.sk</a></li>
			<li><a  href="#5.2">5.14 imple motd.sk</a></li>
			<li><a  href="#5.2">5.15 teleport with compass.sk</a></li>
			<li><a  href="#5.2">5.16 vanilla gui.sk</a></li></ul></li>
			<!-- 6 -->
			<li><a href="#6"" style="font-weight: bold; text-align: center;">6. 你的第一个自定义方块</a><ul>
			<li><a  href="#6">6.1 非功能性方块和功能性方块的区别</a></li>
			<li><a  href="#6.2">6.2 利用optifine的ctm功能自定义材质</a><ul>
			<li><a  href="#6.2.1">6.2.1 各容器mspt对比</a></li>
			<li><a  href="#6.2.2">6.2.2 木桶与熔炉的放置机制问题</a></li>
			<li><a  href="#6.2.3">6.2.3 非功能性方块制作</a></li></ul>
			<li><a  href="#6.3">6.3 原版自定义方块</a></li></ul></li>
			<!-- 7 -->
			<!-- 8 -->
			<!-- 9 -->
			<!-- 测试 -->
			<li>
			<a href="#X"" style="font-weight: bold; text-align: center;">多分组测试</a><ul>
			<li><a href="#X">多分组测试1</a></li>
			<li><a href="#X">多分组测试2</a><ul>
			<li><a href="#X">多分组测试3</a></li></ul></li>
			<li><a href="#X">多分组测试4</a></li>
			</ul></li>
		</ul>
	</nav>
	<!-- 内容 -->
	<div id="main_part">
		&emsp;&emsp;&emsp;
		<a href=""><img src="images/sk_logo.png" style="margin:0 0 -60 0;width:5%"></a>&emsp;
		<a href="https://mineplugin.org/Skript"><img src="images/sk_plugin_wiki_logo.png" style="margin:0 0 -60 0;width:7%"></a>&emsp;
		<a href="https://skripthub.net/docs/"><img src="images/sk_hub_logo.png" style="margin:0 0 -60 0;width:4.2%"></a>&emsp;
		<a href="https://docs.skunity.com"><img src="images/skunity_logo.png" style="margin:0 0 -60 0;width:5.3%"></a>&emsp;
		<a href="http://en.njol.ch/projects/skript/doc/events"><img src="images/skript_events_logo.png" style="margin:0 0 -60 0;width:5%"></a>&emsp;


		<article>
		<!-- 1 -->
		<h1 id="1">1. What is MNORPG?<a href="https://www.bilibili.com/video/BV1Mp4y1Y74H"><img src="images/bilibili_logo.png" style="width:70px;margin-right:25px;"></a></h1>
			<!-- 1.1 -->
			<h3 id="1.1">1.1 MNORPG在RPG游戏中的定位1</h3>
			<p>
			MNORPG即<code>Mavssive None Online Role-Playing Game</code>(大型非在线角色扮演游戏).
			MNORPG的设计思路与传统MMORPG最大的区别在于,MNORPG是一个<code>不需要</code>任何玩家参与仍然可以运行的游戏.
			如果你真想从零开发一个优秀的RPG Server,不妨好好看看该Wiki
			</p>
			<!-- 1.2 -->
			<h3 id="1.2">1.2 MNORPG第一主题</h3>
			<p>
			<code>具现化</code>(具体实现化Concrete Realization Phenomenon)
			在MNORPG游戏类型中,世界都必须围绕着这个运行.
			任何一个NPC说的一句话,任何一本书记载的位置,任何一个漂流瓶记载的事情,在游戏中都必须有所体现.
			举个例子,如果一把武器中的描述中有:该武器曾经是布鲁托铁匠使用过的,
			那么在服务器中,就必须要有布鲁托这个NPC,即便他死了
			</p>
			<!-- 1.3 -->
			<h3 id="1.3">1.3 MNORPG第二主题</h3>
			<p>
			<code>成长</code>(成长的故事Adolescent Story)
			要想把MNORPG的故事写的精彩,光是固定的剧情显然是不够的.
			每段故事如果能让NPC若有成长,这个故事就是精彩的.
			剧本这块要下大功夫并不容易,讲好各个角色的故事非常重要
			</p>
		<!-- 2 -->
		<h1 id="2">2. 服务器版本的选择<a href="https://www.bilibili.com/video/BV1Kp4y1Y72L"><img src="images/bilibili_logo.png" style="width:70px;margin-right:25px;"></a></h1>
			<!-- 2.1 -->
			<h3 id="2.1">2.1 游戏版本的选择</h3>
			<p>
			在选择版本之前,我们需要明白一个道理,该系列不沾任何服务端MOD,如果你想使用MOD来打造RPG服务器,</br>
			那么你与该系列的无缘的(更新该WIKI时最高版本:1.18).
			第一要确定一件事,我们要开的RPG服务器版本要选择哪一个,粗略分析以下几个原因</br>
			<code>1:</code>
			在1.14以下的所有版本中,所有服务器都无法避免地图光照更新产生的黑块问题.
			尽管目前有光照更新修复等插件,诞生效果不尽人意.
			在使用optifine的清澈水体时,没有任何一款插件能修复水底光照问题</br>
			<code>2:</code>
			1.14以下的版本杂且乱,1.14以下版本都无法做到超视距问题(服务器视距>10).
			这对于RPG游戏体验是极大的破坏.</br>
			<code>3:</code>
			在1.13以下的版本缺少游泳动作,RPG的总体互动性会缺少一些该有的乐趣.
			海底BOSS的设计及潜水设计.</br>
			<code>4:</code>
			Minecraft目前最头疼的问题,1.15以下的所有版本中优化都是极其拉跨的(包括1.12).
			以上几个原因,我们可以得出目前相对比较适合的游戏版本是<code>1.15.2</code>
			视频中虽然说是1.14.4,但那是以前的视频.
			</p>
			<!-- 2.2 -->
			<h3 id="2.2">2.2 服务端核心的选择<a href="https://www.bilibili.com/video/BV1Kp4y1Y72L"><img src="images/bilibili_logo.png" style="width:70px;margin-right:25px"></a></h3>
			<p>
			这里就不详细科普各个服务端的优缺点了,在MNORPG这个需要大量运算脚本的服务器里.
			选择一款<code>多线程处理</code>的服务端非常重要,曾经我用过Spigot来运算上百个盔甲架,已经hold不住了.
			你可能会好奇,上百个那么多?给你打个预防针,上百个很正常
			</p>
		<!-- 3 -->
		<h1 id="3">3. Skript的介绍<a href="https://www.bilibili.com/video/BV1d54y1677h"><img src="images/bilibili_logo.png" style="width:70px;margin-right:25px;"></a></h1>
			<!-- 3.1 -->
			<h3 id="3.1">3.1 Skript的基本结构</h3>
			<p>
			Skript是一个在国外非常流行的服务器插件,它允许你在不会Java语言的情况下简单的管理整个Minecraft.
			这是用<code>触发式</code>、<code>条件式</code>和<code>表达式</code>三个部分做到的.</br>
			&emsp;&emsp;触发器很普通,并由一些条件和效果组成,就像这个简单的掉落脚本.
			当触发器触发,所有条件均满足,效果就会被触发,简单吧?</br>
			&emsp;&emsp;每个服务器都能在没有自定义插件的情况下表现出属于自己的光彩这比你自己钻研插件和找人写插件快的多.
			同时你也不需要那么多小插件了,</br>
			这一个插件就够了,例如我服务器的所有插件,仅有Skript及扩展+MythicMobs,
			为了方便交流,我们今后会,把skript简化成sk进行说明
<pre>
<span class="comment">当打破方块时:</span>
<span class="comment">  如果方块是玻璃:</span>
<span class="comment">    掉落玻璃:</span>
on break:
  if event-block is glass:
    drop glass
</pre>
			</p>
			<!-- 3.2 -->
			<h3 id="3.2">3.2 Skript及扩展的下载</h3>
			<p>
			你可以在<a href="https://github.com/bensku/Skript/releases">GITHUB</a>上下载最新版本的Skript.
			扩展如果你第一次使用sk,请不要加,等用到时再自己加,以下是几个比较实用的扩展.</br>
			更多扩展你可以在SkHub上找到下载地址</br>
			&emsp;&emsp;SkBee : <a href="https://www.spigotmc.org/resources/skbee-skript-addon.75839/">Download</a></br>
			&emsp;&emsp;Skellett : <a href="https://forums.skunity.com/resources/skellett-the-beast-addon.24/">Download</a></br>
			&emsp;&emsp;SkQuery : <a href="https://github.com/SkQuery/SkQuery/releases">Download</a></br>
			&emsp;&emsp;skUtilities : <a href="https://forums.skunity.com/resources/skutilities.26/">Download</a></br>
			&emsp;&emsp;TuSKe : <a href="https://github.com/Tuke-Nuke/TuSKe/releases">Download</a></br>
			不同sk版本可以在不同的版本中运行,包括扩展也是一样的.
			2017年的TuSKe1.8.2在2021年的今天仍然可以运行在1.16版本上</br>
	     	</p>
		<!-- 4 -->
		<h1 id="4">4. 学习Skript需要的准备</h1>
			<!-- 4.1 -->
			<h3 id="4.1">4.1 Skript的定位</h3>
			<p>
			我们先来明确一下Skript在Minecraft是怎么样一种定位,
			Skript是脚本插件,它相较于Java,更多是<code>逻辑</code>上的学习过程.</br>
			同时它的容错率更高,格式要求也更加灵活
			</p>
			<!-- 4.2 -->
			<h3 id="4.2">4.2 编写工具</h3>
			<p>
			sk的脚本文件非常轻量化,你可以不使用Visual Studio Code、Atom等复杂的工具.如果你有使用过VSC或其他工具,那当然是最好的.</br>
			在初次编写sk,我建议各位试试<code>Sublime</code></br>
			<img src="images/1.png" style="width:100%"></br>
			在使用Sublime打开<code>.sk</code>文件时,</br>
			点击右下角<code>纯文本</code>→<code>open all with current extension as...</code>→<code>Yaml</code>这样下次打开sk就以Yaml文本的形式打开了
			</p>
			<!-- 4.3 -->
			<h3 id="4.3">4.3 善用DOC</h3>
			<p>
			在<a href="https://skripthub.net/docs/">https://skripthub.net/docs/</a>里,你可以找到大量的sk语法.
			你可以在本网页的Top里找到<code>Skript Hub</code>进入并加入收藏夹.</br>
			你前期能死磕的语法的地方只有sk hub,有大量的语法是存在例子的
			</p>
			<!-- 4.4 -->
			<h3 id="4.4">4.4 笔记的重要性</h3>
			<p>
			之前说过了,sk是注重逻辑处理的编写语言,它没有JAVA的复杂性,所以做好相应的笔记非常重要.
			在我学习sk的时候,我记录不下千行的sk语句例子,这些例子在今天,我一样会经常翻阅
			<img src="images/2.png" style="width:100%">
			</p>
		<!-- 5 -->
		<h1 id="5">5. Skript的官方例子分析</h1>
			<!-- 5.1 -->
			<h3 id="5.1">5.1 脚本命名规则</h3>
			<p>
			sk的加载是有序列顺序的</br>
			<img src="images/13.png"></br>
			<img src="images/14.png"></br>
			优先级顺序如下:</br>
			<code>符号>数字>字母>汉字</code></br>
			<code>!</code>表示最低优先级(最先加载),如果要写一些function(函数)请在里边写</br>
			第一字符含有<code>-</code>的脚本会被sk跳过加载</br>
			已经加载的脚本,可更改文件名后再reload一下即可停用
			或者你喜欢输入/sk disable &lt;skript>也可以</br>
			</p>
			<!-- 5.2 -->
			<h3 id="5.2">5.2 例子分析</h3>
			<p>
			<a href="html/index.html">去老wiki查看</a>
			</p>
		<!-- 6 -->
		<h1 id="6">6. 你的第一个自定义方块</h1>
			<!-- 6.1 -->
			<h3 id="6.1">6.1 非功能性方块和功能性方块的区别</h3>
			<p>
			<code>非功能性方块</code>:像石头,草方块,橡木木板这类不具备交互功能的方块,通常模型大小为1m³</br>
			<img src="images/3.png" style="width:100%"></br>
			<code>功能性方块</code>:像熔炉,切石机,灯笼这类<code>具有独立GUI</code>或<code>特殊模型碰撞箱</code></br>
			<img src="images/4.png" style="width:100%"></br>
			这也是本章会着重讲解的方块</br>
			你可以学会自定义方块材质自定义方块模型,自定义方块碰撞箱,自定义方块GUI及功能</br>
			本章里,你将会学习到optifine的ctm的自定义贴图,cit的自定义物品</br>
			如果你第一次接触optifine的这些功能,可以前往<a href="https://www.mcbbs.net/thread-782790-1-1.html">https://www.mcbbs.net/thread-782790-1-1.html</a>粗略了解</br>
			</p>
			<!-- 6.2 -->
			<h3 id="6.2">6.2 利用optifine的ctm功能自定义材质</h3>
			<p>
			例子材质包下载<a href="file/CTM例子.zip" download="CTM例子.zip">Download</a></br>
			在游戏里用铁砧命名熔炉为<code>new_block</code>即可使用</br>
			(只有亲自体验才能知道这篇里在讲什么)</br>
			要想利用ctm来自定义材质,首先第一要求就是必须拥有<code>CustomName</code>这个nbt</br>
			通过自定义某个容器的GUI名字,我们就可以用ctm来实现改方块的各面材质</br>
			就像下图,同是熔炉,,熔炉GUI名字不同,材质也随着不同</br>
			<img src="images/5.png" style="width:100%"></br>
			那么第一个问题就来了,既然那么多具有GUI命名的容器方块</br>
			如何选择最佳的那一个呢?在<a href="https://www.bilibili.com/video/BV1fX4y1K78C">BV1fX4y1K78C</a>这期视频开头里</br>
			我对比了刷怪笼自定义方块和盔甲架自定义方块的帧数(需要说明的是那个自定义方块原理和本篇是不同的)</br>
			视频里没有对比<code>mspt</code>(1tick需要多长时间运行,越低越好)是因为没有利用容器进行修改</br>
			在本WIKI里我将详细对比2种自定义方块的mspt情况(请不要追求极致去用唱片机来自定义)</br>
			</p>
			<!-- 6.2.1 -->
			<h3 id="6.2.1">6.2.1 各容器mspt对比<a href="https://www.bilibili.com/video/BV1HX4y1A7YL"><img src="images/bilibili_logo.png" style="width:70px;margin-right:25px;"></a></h3>
			<p>
			烟熏炉(smoker)30³ : mspt=8-10 fps=550/120</br>
			&emsp;&emsp;发射器(dispenser)30³ : mspt=6-7 fps 600/260</br>
			&emsp;&emsp;附魔台(enchantment table)30³ : mspt=5-6 fps=4/3</br>
			&emsp;&emsp;高炉(blast furnace)30³ : mspt=7 fps=600/130</br>
			&emsp;&emsp;漏斗(hopper)30³ : mspt=26 fps=230/150</br>
			&emsp;&emsp;<code>木桶(barrel)</code>30³ : mspt=3-4 fps=688/200-320</br>
			&emsp;&emsp;酿造台(brewing stand)30³ : mspt=6-7 fps=240/100</br>
			&emsp;&emsp;潜影盒(shulker box)30³ : mspt=3-4 fps=11/10</br>
			&emsp;&emsp;投掷器(smoker)30³ : mspt=3-4 fps=670/300</br>
			&emsp;&emsp;箱子(chest)30³ : mspt=6-7 fps=8/7</br>
			&emsp;&emsp;陷阱箱(trapped chest)30³ : mspt=3-4 fps=8/7</br>
			&emsp;&emsp;<code>熔炉(furnace)</code>30³ : mspt=3-5 fps=600/140</br>
			&emsp;&emsp;<code>盔甲架(armor stand)</code>30³ : mspt=500+ fps=0</br>
			通过以上mspt和fps的对比,当前版本下,空的木桶的综合考虑是最优秀的</br>
			</p>
			<!-- 6.2.2 -->
			<h3 id="6.2.2">6.2.2 木桶与熔炉的放置机制问题</h3>
			<p>
			<code>木桶</code>的放置朝向一共拥有6个,分别为上、下、左、右、前、后.在实际使用中,就拥有6种放置角度</br>
			<img src="images/6.png" style="width:100%"></br>
			再看看<code>熔炉</code>的放置朝向,仅有4个,分别为左、右、前、后</br>
			<img src="images/7.png" style="width:100%"></br>
			根据你想要做的方块选择对应的载体(木桶/熔炉)</br>
			我建议大家选择木桶作为载体,要想禁止上下面到后面我会教用sk来阻止</br>
			</p>
			<!-- 6.2.3 -->
			<h3 id="6.2.3">6.2.3 非功能性方块制作</h3>
			<p>
			首先准备一个方块的贴图,这里我拿工业2的核弹做演示例子</br>
			<img src="images/8.png" style="width:100%"></br>
			一个方块共有3个部分的贴图组成,分别是<code>top(顶部)</code>、<code>bottom(底部)</code>、<code>side(侧面)</code></br>
			要是你使用了熔炉作为载体,则还有front(前面),不举例</br>
			</br>
			<code>第一步:</code></br>
			在<code>材质包/assets/minecraft/optifine/ctm/新方块名字/</code>路径下放入刚才的3个贴图</br>
			<img src="images/9.png" style="width:100%"></br>
			<code>第二步:</code></br>
			创建各个贴图对应的<code>.properties</code>文件</br>
			<img src="images/10.png" style="width:100%"></br>
			<code>第三步:</code></br>
			编写.properties,填入以下信息</br>
<pre>
bottom.properties:
	matchTiles=barrel_bottom
	method=fixed
	tiles=bottom
	name=ces

sides.properties:
	matchTiles=barrel_side
	method=fixed
	tiles=sides
	name=ces

top.properties
	matchTiles=barrel_top
	method=fixed
	tiles=top
	name=ces
</pre>
			<img src="images/11.png" style="width:100%"></br>
			<code>逐句分析:</code></br>
			matchTiles=<方块各面ID></br>
			method=ctm / horizontal / vertical / top / random / repeat / fixed</br>
			tiles=<贴图对应.png文件></br>
			name=&lt;GUI名字判定></br>
			你想更深入了解CTM可以去看看<a href="https://www.mcbbs.net/thread-103270-1-1.html">https://www.mcbbs.net/thread-103270-1-1.html</a></br>
<pre>
method的区别
ctm        <span class="comment">标准的连接方式,任意方向上有相同方块连接时会出现效果,这有点类似于原版中的玻璃方块</span>
horizontal <span class="comment">水平方向连接方式,水平方向有相同方块连接时会出现效果,也就是书架的效果</span>
vertical   <span class="comment">垂直方向连接方式,垂直方向有相同方块连接时会出现效果,可以用来做柱子的效果</span>
top        <span class="comment">顶部连接方式,当方块上方有相同方块连接时方块本身会出现效果</span>
random     <span class="comment">随机材质,方块随机使用数个选定的材质</span>
repeat     <span class="comment">重复材质,方块连续使用选定的一定面积的材质</span>
fixed      <span class="comment">固定材质,方块固定使用一个选定的材质</span>
</pre>
			<code>第四步:</code></br>
			进入游戏用铁砧给木桶命名为ces</br>
			便可以得到以下方块</br>
			<img src="images/12.png" style="width:100%"></br>
			<code>第五步:</code></br>
			编写一个sk来禁止打开容器,原理:判定nbt(需要SkBee)</br>
<pre>
on right click:
  set {_nbt} to tag "CustomName" of nbt of event-block
  if {_nbt} contain "ces":
    cancel event

<span class="comment">右键触发:</span>
<span class="comment">  设置变量{_nbt}为目标方块nbt的"CustomName"部分</span>
<span class="comment">  如果变量{_nbt}包含"ces"字符:</span>
<span class="comment">    取消事件</span>
</pre>


			</p>














		</article>
		<!--<figure><img src="images/12.png" height="180" width="900"></figure>-->
	</div>
</body>
</html>